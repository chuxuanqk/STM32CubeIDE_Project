/*
 * uart.c
 *
 *  Created on: 2020年9月14日
 *      Author: Administrator
 */
#include "uart.h"
#include "stdio.h"

/* USART1 */
#define UART1_GPIO_TX GPIO_Pin_9
#define UART1_GPIO_RX GPIO_Pin_10
#define UART1_GPIO GPIOA

/* USART2 */
#define UART2_GPIO_TX GPIO_Pin_2
#define UART2_GPIO_RX GPIO_Pin_3
#define UART2_GPIO GPIOA

/* USART3_REMAP[1:0] = 00 */
#define UART3_GPIO_TX GPIO_Pin_10
#define UART3_GPIO_RX GPIO_Pin_11
#define UART3_GPIO GPIOB

__attribute__((weak)) void uart_read(struct uart_data * pdata){ return;}

static void RCC_Configuration(void)
{
    /* Enable UART GPIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    /* Enable UART clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);

    /* Enable UART GPIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    /* Enable UART clock */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

    /* Enable UART GPIO clocks */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    /* Enable UART clock */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
}

static void GPIO_Configuration(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

    /* Configure USART Rx/tx PIN */
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_InitStructure.GPIO_Pin = UART1_GPIO_RX;
    GPIO_Init(UART1_GPIO, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = UART1_GPIO_TX;
    GPIO_Init(UART1_GPIO, &GPIO_InitStructure);

    /* Configure USART Rx/tx PIN */
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_InitStructure.GPIO_Pin = UART2_GPIO_RX;
    GPIO_Init(UART2_GPIO, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = UART2_GPIO_TX;
    GPIO_Init(UART2_GPIO, &GPIO_InitStructure);

    /* Configure USART Rx/tx PIN */
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_InitStructure.GPIO_Pin = UART3_GPIO_RX;
    GPIO_Init(UART3_GPIO, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = UART3_GPIO_TX;
    GPIO_Init(UART3_GPIO, &GPIO_InitStructure);
}

static void UART_Configuration(struct uart_device* uart, struct uart_configure *cfg)
{
  USART_InitTypeDef USART_InitStructure;

  USART_InitStructure.USART_BaudRate = cfg->baud_rate;

  if (cfg->data_bits == DATA_BITS_8)
  {
      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  }
  else if (cfg->data_bits == DATA_BITS_9)
  {
      USART_InitStructure.USART_WordLength = USART_WordLength_9b;
  }

  if (cfg->stop_bits == STOP_BITS_1)
  {
      USART_InitStructure.USART_StopBits = USART_StopBits_1;
  }else if (cfg->stop_bits == STOP_BITS_1_5) {
    USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
  }
  else if (cfg->stop_bits == STOP_BITS_2)
  {
      USART_InitStructure.USART_StopBits = USART_StopBits_2;
  }

  if (cfg->parity == PARITY_NONE)
  {
      USART_InitStructure.USART_Parity = USART_Parity_No;
  }
  else if (cfg->parity == PARITY_ODD)
  {
      USART_InitStructure.USART_Parity = USART_Parity_Odd;
  }
  else if (cfg->parity == PARITY_EVEN)
  {
      USART_InitStructure.USART_Parity = USART_Parity_Even;
  }
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  USART_Init(uart->uartx, &USART_InitStructure);

  USART_DMACmd(uart->uartx, USART_DMAReq_Tx, ENABLE); //串口采用DMA发送
  USART_ITConfig(uart->uartx, USART_IT_RXNE, ENABLE); //接收中断使能

  /* Enable USART */
  USART_Cmd(uart->uartx, ENABLE);
}


#ifdef USE_USART_DMA_RX
static void UART_DMA_Rx_Config(struct uart_data* pdata)
{
    DMA_InitTypeDef DMA_InitStructure;
    struct uart_device *uart = pdata->uart_device;

    // 开启DMA时钟
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    // 设置DMA源地址：串口数据寄存器地址*/
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(uart->uartx->DR);
    // 内存地址(要传输的变量的指针)
    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pdata->stream_rx;
    // 方向：从内存到外设
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    // 传输大小
    DMA_InitStructure.DMA_BufferSize = USART_RX_BUFF_SIZE;
    // 外设地址不增
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    // 内存地址自增
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    // 外设数据单位
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    // 内存数据单位
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    // DMA模式，一次或者循环模式
    //DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    // 优先级：中
    DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
    // 禁止内存到内存的传输
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    // 配置DMA通道
    DMA_Init(&uart->dma->rx_irq_ch, &DMA_InitStructure);
    // 清除DMA标志
    DMA_ClearFlag(uart->dma->rx_gl_flag);
    DMA_ITConfig(&uart->dma->rx_irq_ch, DMA_IT_TE, ENABLE);
    // 使能DMA
    DMA_Cmd (&uart->dma->rx_irq_ch,ENABLE);
}
#endif


#ifdef USE_USART_DMA_TX
static void UART_DMA_Tx_Config(struct uart_data* pdata)
{
  DMA_InitTypeDef DMA_InitStructure;
  struct uart_device *uart = pdata->uart_device;

  //启动DMA时钟
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

  //DMA1通道4配置
  DMA_DeInit(DMA1_Channel4);
  //外设地址
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(pdata->uart_device->uartx->DR);
  //内存地址
  DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pdata->stream_tx;
  //dma传输方向单向
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
  //设置DMA在传输时缓冲区的长度
  DMA_InitStructure.DMA_BufferSize = UART_DMA_RB_BUFSZ;
  //设置DMA的外设递增模式，一个外设
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  //设置DMA的内存递增模式
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  //外设数据字长
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  //内存数据字长
  DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;
  //设置DMA的传输模式
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
  //设置DMA的优先级别
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  //设置DMA的2个memory中的变量互相访问
  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;

  DMA_Init(uart->dma_tx.tx_irq_ch, &DMA_InitStructure);
  DMA_ITConfig(uart->dma_tx.tx_irq_ch, DMA_IT_TC, ENABLE);
}
#endif

static void NVIC_Configuration(struct uart_device *uart)
{
    NVIC_InitTypeDef NVIC_InitStructure;

    /* Enable the USART1 Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = uart->irq;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

int16_t uart_getc(USART_TypeDef* uartx)
{
  int16_t ch = -1;

  if(uartx->SR & USART_FLAG_RXNE){
      ch = uartx->DR & 0x01FF;
  }
  return ch;
}


static void uart_isr(struct uart_data *uart)
{
  USART_TypeDef* uart = uart->uart_device->uartx;
  if (USART_GetITStatus(uart, USART_IT_RXNE) != RESET)
  {
      /* 奇偶校验错误检测，无校验错误 */
      if (USART_GetFlagStatus(uart, USART_FLAG_PE) == RESET)
      {
//	  uart_read(uart);	// 钩子函数
	  uart->stream_rx[uart->rx_index++] = uart_getc(uart);

	  if(uart->rx_index == uart->recv_len)
	    uart->rx_flag = true;
      }
      /* clear interrupt */
      USART_ClearITPendingBit(uart, USART_IT_RXNE);
  }

#ifdef USE_USART_DMA_RX
  /* 检测到总线空闲，USART_CR1的IDLEIE为1 */
  if (USART_GetFlagStatus(uart, USART_IT_IDLE) != RESET)
  {

  }
#endif

  /* 一帧数据发送完成后，并且TXE=1时即数据已经被转移到移位寄存器中， USART_CR1中的TCIE为1产生中断*/
  if (USART_GetFlagStatus(uart, USART_IT_TC) != RESET)
  {
      /* clear interrupt */

      USART_ITConfig(uart, USART_IT_TC, DISABLE);
      USART_ClearITPendingBit(uart, USART_IT_TC);
  }

  /* 检测到过载错误，当RXNE仍是1时，当前被接收在移位寄存器中的数据，需要传送至RDR寄存器是，硬件将该位 置位 */
  if (USART_GetFlagStatus(uart, USART_FLAG_ORE) == SET)
  {
      USART_ReceiveData(uart);
  }

}

#ifdef USING_UART1
struct uart_configure config1=UART_CONFIG_DEFAULT;
struct uart_device uart1 = {
    USART1,
    USART1_IRQn,

#ifdef USE_USART_DMA_RX
    .dma_rx = {
        DMA1_Channel5,
        DMA1_FLAG_GL5,
        DMA1_Channel5_IRQn,
        0,
    },
#endif

#ifdef USE_USART_DMA_TX
    .dma_tx = {
	DMA1_Channel4,
	DMA1_FLAG_GL4,
	DMA1_Channel4_IRQn,
    }
#endif

};
struct uart_data duart1 = {
    .uart_device = &uart1,
    .flag = false,
    .rx_index = 0,
    .recv_len = 2,
};

void USART1_IRQHandler(void)
{
  uart_isr(&duart1);
}
#endif

#ifdef USING_UART2
struct uart_configure config2=UART_CONFIG_DEFAULT;
struct uart_device uart2 = {
    USART2,
    USART2_IRQn,

#ifdef USE_USART_DMA_RX
    .dma_rx ={
        DMA1_Channel6,
        DMA1_FLAG_GL6,
        DMA1_Channel6_IRQn,
        0,
    },
#endif

#ifdef USE_USART_DMA_TX
    .dma_tx = {
	DMA1_Channel7,
	DMA1_FLAG_GL7,
	DMA1_Channel7_IRQn,
    }
#endif

};
struct uart_data duart2 = {
    .uart_device = &uart2,
    .flag = false,
    .rx_index = 0,
    .recv_len = 2,
};


void USART2_IRQHandler(void)
{
  uart_isr(&duart2);
}
#endif

#ifdef USING_UART3
struct uart_configure config3=UART_CONFIG_DEFAULT;
struct uart_device uart3 = {
    USART3,
    USART3_IRQn,

#ifdef USE_USART_DMA_RX
    .dma_rx = {
        DMA1_Channel3,
         DMA1_FLAG_GL3,
         DMA1_Channel3_IRQn,
         0,
    },
#endif

#ifdef USE_USART_DMA_TX
    .dma_tx = {
	DMA1_Channel2,
	DMA1_FLAG_GL2,
	DMA1_Channel2_IRQn,
    }
#endif
};
struct uart_data duart3 = {
    .uart_device = &uart3,
    .flag = false,
    .rx_index = 0,
    .recv_len = 2,
};


void USART3_IRQHandler(void)
{
  uart_isr(&duart3);
}
#endif


int16_t uart_read(USART_TypeDef* uartx, uint8_t *pbuf, uint8_t size)
{
  struct uart_data *pstream;
  uint8_t i;
  int16_t ret=-1;

  if(USART1 == uartx)
     pstream = duart1;
  else if (USART2 == uartx) {
    pstream = duart2;
  }else if (USART3 == uartx) {
    pstream = duart3;
  }

  if(pstream->recv_len != size)
    pstream->recv_len = size;

  if(pstream->rx_flag){
    for(i=0; i<pstream->rx_index; i++){
	pbuf[i] = pstream->stream_rx[i];
    }

    ret = i;
    pstream->rx_flag = false;
    pstream->rx_index = 0;
    memset(pstream->stream_rx, 0, pstream->rx_index);
  }

  return ret;
}

int16_t uart_write(USART_TypeDef* uartx, uint8_t *pbuf, uint8_t size)
{
  struct uart_data *pstream;
  int16_t ret = -1;

  if(USART1 == uartx)
     pstream = duart1;
  else if (USART2 == uartx) {
    pstream = duart2;
  }else if (USART3 == uartx) {
    pstream = duart3;
  }

  if(!pstream->tx_flag){
      //设置数据长度
      DMA_SetCurrDataCounter(pstream->uart_device->dma_tx.tx_ch, USART_Send->data_len);
      //启动DMA发送
      DMA_Cmd(DMA1_Channel4, ENABLE);

      pstream->tx_flag = true;	// 设置发送标志
      ret = size;
  }

  return ret;
}

void hw_uart_init(void)
{
  struct uart_device *uart;

  RCC_Configuration();
  GPIO_Configuration();

#ifdef USING_UART1
  uart = &uart1;
  config1.baud_rate = BAUD_RATE_9600;

  NVIC_Configuration(uart);
  UART_Configuration(uart, &config1);
#endif

#ifdef USING_UART2
  uart = &uart2;
  config2.baud_rate = BAUD_RATE_9600;

  NVIC_Configuration(uart);
  UART_Configuration(uart, &config2);
#endif

#ifdef USING_UART3
  uart = &uart3;
  config3.baud_rate = BAUD_RATE_4800;

  NVIC_Configuration(uart);
  UART_Configuration(uart, &config3);
#endif
}

















