/*
 * dalimaster_control_slave.c
 *
 *  Created on: 2020年10月29日
 *      Author: Saber
 */

#include <dali_cmd.h>
#include <DALImaster.h>
#include "config_par.h"
#include "dalimaster_control_slave.h"

#include "bsp_led.h"
#include "bsp_uart.h"

#define DALI_Port_Number (DALI_LENTH + 1) // 通道0作为整个模块控制，1-64对应DALI短地址 0-63
#define DALI_FADE_TIME 5                  // 渐变等级5 ---  2.8s

struct DALI_Output_Buffer_Struct DALI_Output_Buffer_Str[DALI_Port_Number]; // DALI各通道状态缓存区

uint8_t recv_cycle_index;
bool recv_cycle_flag;

/**
 * @description: 
 * @param {*}
 * @return {*}
 */
void Dali_Init_Control(void)
{
    uint8_t i = 0;

    struct DALI_Output_Buffer_Struct Init_Output_Buf =
        {
            .port_id = 0,
            .set_fade_rate = DALI_FADE_TIME,
            .set_fade_time = DALI_FADE_TIME,
            .set_value = 0,
            .set_sw = 0,
            .now_sw = 0,
            .now_fade_rate = DALI_FADE_TIME,
            .now_fade_time = DALI_FADE_TIME,
            .now_value = 0,
            .ex_value = 0,
            .delta_value = 0,
            .lock_change = false};

    recv_cycle_index = 1;
    recv_cycle_flag = false;

    DALI_Output_Buffer_Str[0] = Init_Output_Buf;                         // 整个模块控制
    Cmd_SetTimeRate(DALI_BORADCAST_ADDR, Init_Output_Buf.now_fade_time); // 先设置渐变率， 后改变亮度等级

    for (i = 1; i < DALI_Port_Number; i++)
    {
        DALI_Output_Buffer_Str[i] = Init_Output_Buf;
        DALI_Output_Buffer_Str[i].port_id = i - 1;
    }
}

/**
 * @description: 获取对应端口号的缓存通道
 * @param {*}
 * @return {*} 
 */
struct DALI_Output_Buffer_Struct *Dali_Get_Port_Buf(uint8_t temp_port)
{
    return &(DALI_Output_Buffer_Str[temp_port]);
}

/**
 * @description: 输入值编码 0~65535  --->  0~254
 * @param {*} value: 0~65535
 * @return {*}
 */
uint16_t Dali_InputValue_encode(uint16_t value)
{
    return (value / DALI_DIMLEVEL_TRANSFORM);
}

/**
 * @description: 输出值解码
 * @param {*}
 * @return {*}
 */
uint16_t Dali_OutputValue_decode(uint16_t value)
{
    return (value * DALI_DIMLEVEL_TRANSFORM);
}

/**
 * @description: 渐变时长转换,按照DALI的渐变时长转换  (0~100s)  ---> DALI Fade time
 * @param {*}
 * @return {*}
 */
static uint8_t Dali_Fadetime_Transform(uint8_t fadetime)
{
    uint8_t fadetime_level = 2;

    switch (fadetime)
    {
    case 0:
        fadetime_level = 0;
        break;

    case 1:
        fadetime_level = 2;
        break;

    case 2:
        fadetime_level = 4;
        break;

    case 3:
        fadetime_level = 5;
        break;

    case 4:
        fadetime_level = 6;
        break;

    default:
        fadetime_level = 2;
        break;
    }

    if ((fadetime >= 5) && (fadetime < 8)) // 5~8s
        fadetime_level = 7;
    else if ((fadetime >= 8) && (fadetime < 11)) // 8~11s
        fadetime_level = 8;
    else if ((fadetime >= 11) && (fadetime < 16))
        fadetime_level = 9;
    else if ((fadetime >= 16) && (fadetime < 22))
        fadetime_level = 10;
    else if ((fadetime >= 22) && (fadetime < 32))
        fadetime_level = 11;
    else if ((fadetime >= 32) && (fadetime < 45))
        fadetime_level = 12;
    else if ((fadetime >= 45) && (fadetime < 64))
        fadetime_level = 13;
    else if ((fadetime >= 64) && (fadetime < 90))
        fadetime_level = 14;
    else if ((fadetime >= 90) && (fadetime <= 100))
        fadetime_level = 15;

    return fadetime_level;
}

/**
 * @description:  更新各DALI镇流器通道数据，根据设置参数+相应转换算法对数据进行更新处理
 * @param {*} temp_buf: x通道的结构体指针
 * @return {*}
 */
void Dali_Update_Set_Value(struct DALI_Output_Buffer_Struct *temp_buf)
{

    temp_buf->lock_change = true; // 上锁

    if (temp_buf->set_value != 0)
        temp_buf->set_sw = SW_OPEN;
    else
        temp_buf->set_sw = SW_CLOSE;

    // 转换set_value: 0~65535  --->  0~254
    // temp_buf->set_value = (temp_buf->set_value / DALI_DIMLEVEL_TRANSFORM);
    temp_buf->set_value = Dali_InputValue_encode(temp_buf->set_value);

    // 渐变时长
    // 接收的主机给的渐变率 0~100%/s, 即每秒钟变化的百分比
    temp_buf->set_fade_time = temp_buf->set_fade_time;

    temp_buf->lock_change = false; // 解锁
}

/**
 * @description: DALI通道状态是否改变 
 * @param {*}
 * @return {*} YES:true   NO:false
 */
static bool Dali_Status_Change(uint8_t temp_port)
{
    bool rflag = false;
    const struct DALI_Output_Buffer_Struct *output_buf;

    // if (temp_port > 0)
    //     temp_port = temp_port - 1;

    output_buf = Dali_Get_Port_Buf(temp_port);

    if ((output_buf->lock_change == false) &&
        ((output_buf->set_fade_rate != output_buf->now_fade_rate) ||
         (output_buf->set_fade_time != output_buf->now_fade_time) ||
         (output_buf->set_value != output_buf->now_value)))
    {
        rflag = true;
    }

    return rflag;
}

/**
 * @description: DALI通道数据查询，并更新数据到当前值
 *              ps:如以后还需添加查询参数，需要考虑将查询定时器时间加长。目的:不影响正常控制。
 * @param {*}
 * @return {*}
 */
static void Dali_Reflash_Recv(uint8_t temp_port)
{
    uint8_t answer = 0;
    uint8_t short_addr = temp_port - 1;
    struct DALI_Output_Buffer_Struct *temp_buf = &DALI_Output_Buffer_Str[temp_port];

    Cmd_QueryDimLevel(short_addr);
    answer = dali_read_backwardframe();
    temp_buf->now_value = answer;

    Cmd_QueryFateAndTimeRate(short_addr);
    answer = dali_read_backwardframe();
    temp_buf->now_fade_time = (answer & 0xF0) >> 4;
    temp_buf->now_fade_rate = answer & 0x0F;
}

/**
 * @description: 将其放入定时任务中, 用于置位查询flag
 * @param {*}
 * @return {*}
 */
void Dali_Set_RecvFlag(void)
{
    recv_cycle_flag = true;
}

/**
 * @description: 
 * @param {*}
 * @return {*}
 */
void Dali_Reset_RecvFlag(void)
{
    recv_cycle_flag = false;
}

/**
 * @description: 清除所有通道信息
 * @param {*}
 * @return {*}
 */
void Dali_Clear_All_Channle_Data(void)
{
    uint8_t i = 0;
    struct DALI_Output_Buffer_Struct *temp_buf;

    for (; i < DALI_Port_Number; i++)
    {
        temp_buf = &DALI_Output_Buffer_Str[i];
        temp_buf->port_id = 0;
        temp_buf->set_fade_rate = DALI_FADE_TIME;
        temp_buf->set_fade_time = DALI_FADE_TIME;
        temp_buf->set_value = 0;
        temp_buf->set_sw = 0;
        temp_buf->now_fade_rate = DALI_FADE_TIME;
        temp_buf->now_fade_time = DALI_FADE_TIME;
        temp_buf->now_value = 0;
        temp_buf->now_sw = 0;

        temp_buf->lock_change = false;
    }
}

/**
 * @description: 删除DALI镇流器短地址
 * @param {*}
 * @return {*}
 */
void Dali_Delete_ShortAddr(uint8_t shortaddr)
{
    uint8_t addr = 0;

    if (shortaddr == DALI_CLEAR_ALL_CHANNLE) // 清除所有镇流器短地址
    {
        for (addr = 0; addr < DALI_LENTH; addr++)
            Cmd_DelShortAddr(addr);
    }

    if (shortaddr < DALI_LENTH)
        Cmd_DelShortAddr(addr);

    return;
}

/**
 * @description: 用于更新短地址0的镇流器
 * @param {*} shortaddr:用于替换短地址0的地址
 * @return {*}
 */
void Dali_Update_ShortAddr(uint8_t shortaddr)
{
    uint8_t zero_addr = 0;

    Update_ShortAddr(zero_addr, shortaddr);

    return;
}

/**
 * @description: 提供外部控制灯具亮度等级
 * @param {*} value : 0~65535
 * @return {*}
 */
void Dali_Control_Dimlevel(uint8_t channle, uint16_t value)
{
    uint8_t i = 1;
    uint8_t short_addr = channle;
    uint16_t temp_value = value;
    struct DALI_Output_Buffer_Struct *temp_buf;

    // 广播命令，同步所有通道状态
    if (channle == DALI_BORADCAST_ADDR)
    {
        for (i = 1; i < DALI_Port_Number; i++)
        {
            temp_buf = Dali_Get_Port_Buf(i);
            temp_buf->set_value = Dali_InputValue_encode(value);
            temp_buf->now_value = Dali_InputValue_encode(value);
        }
    }

    temp_value = Dali_InputValue_encode(temp_value);

    Cmd_SetDimLevel(short_addr, temp_value);

    return;
}

/**
 * @description: 将其放入定时任务中， 定时查询各通道状态, 
 *               由于DALI传输速率低，导致查询过程过长。
 * @param {*}
 * @return {*}
 */
void Dali_Update_Slave_Status(void)
{
    if (recv_cycle_flag == true)
    {
        Dali_Reset_RecvFlag();

        if (Is_Config_portid(recv_cycle_index) == true)
            Dali_Reflash_Recv(recv_cycle_index);

        recv_cycle_index++;
        if (recv_cycle_index == DALI_Port_Number)
            recv_cycle_index = 1; // 重新查询所有通道
    }
}

/**
 * @description: DALI各通道状态刷新
 *              TODO: 添加分支，不同步计算渐变时间，原因:减低镇流器ROM的写入次数，延迟寿命
 * @param {*}
 * @return {*}
 */
void Dali_Reflash_Output(void)
{
    // uint8_t answer = 0;
    // Config_Data_Str *temp_config = Get_Config_data();
    uint16_t t_fadetime = 0;
    int16_t value_deviation = 0;
    uint8_t short_addr = 0;
    struct DALI_Output_Buffer_Struct *temp_buf;
    static uint8_t send_cycle_index = 0;

    if ((Is_Config_portid(send_cycle_index) == true) && (Dali_Status_Change(send_cycle_index) == true))
    {
        state_led_sharp();

        temp_buf = &DALI_Output_Buffer_Str[send_cycle_index];
        temp_buf->now_fade_time = temp_buf->set_fade_time;
        value_deviation = ((int16_t)temp_buf->now_value - (int16_t)temp_buf->set_value); // 计算前后2次的亮度等级差值
        temp_buf->now_value = temp_buf->set_value;
        // temp_buf->now_fade_rate = temp_buf->set_fade_rate;

        // DALI实际设置渐变时长时，需要根据当前值和设置值，计算出需要设置的渐变时长，即 (set_fade_time*(now_value-set_value))/255
        if (value_deviation == 0)
            value_deviation = 1;
        else if (value_deviation < 0)
            value_deviation = -value_deviation;

        // 修改为不不同计算渐变率，所以此部分会先保留
        // t_fadetime = (value_deviation * 100) / (temp_buf->now_fade_time * DALI_DIMLEVEL_MAX);
        // t_fadetime = Dali_Fadetime_Transform(t_fadetime);

        if (send_cycle_index == 0) // 广播更新所有通道状态, 通道0做为整个模块控制
            short_addr = DALI_BORADCAST_ADDR;
        else
            short_addr = send_cycle_index - 1;

        if (temp_buf->now_fade_time != temp_buf->set_fade_time)
        {
            temp_buf->now_fade_rate = temp_buf->set_fade_rate;
            t_fadetime = 100 / temp_buf->now_fade_time;
            t_fadetime = Dali_Fadetime_Transform(t_fadetime);
            Cmd_SetTimeRate(short_addr, t_fadetime); // 先设置渐变率， 后改变亮度等级
        }

        Cmd_SetDimLevel(short_addr, temp_buf->now_value);
        // Cmd_SetFateRate(short_addr, temp_buf->now_fade_rate);    // 渐变率用于调节单步+-的亮度调节
    }

    send_cycle_index++;

    if (send_cycle_index == DALI_Port_Number)
    {
        send_cycle_index = 0;
    }
}
